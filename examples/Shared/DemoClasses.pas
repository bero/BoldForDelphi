(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2025-12-19                  *)
(*****************************************)

unit DemoClasses;

{$DEFINE DemoClasses_unitheader}
{$INCLUDE DemoClasses_Interface.inc}

const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRootList }

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin
  SetElement(index, NewObject);
end;

{ TPerson }

function TPerson._Get_M_FirstName: TBAString;
begin
  assert(ValidateMember('TPerson', 'FirstName', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TPerson._GetFirstName: String;
begin
  Result := M_FirstName.AsString;
end;

procedure TPerson._SetFirstName(const NewValue: String);
begin
  M_FirstName.AsString := NewValue;
end;

function TPerson._Get_M_LastName: TBAString;
begin
  assert(ValidateMember('TPerson', 'LastName', 1, TBAString));
  Result := TBAString(BoldMembers[1]);
end;

function TPerson._GetLastName: String;
begin
  Result := M_LastName.AsString;
end;

procedure TPerson._SetLastName(const NewValue: String);
begin
  M_LastName.AsString := NewValue;
end;

function TPerson._Get_M_Assets: TBACurrency;
begin
  assert(ValidateMember('TPerson', 'Assets', 2, TBACurrency));
  Result := TBACurrency(BoldMembers[2]);
end;

function TPerson._GetAssets: Currency;
begin
  Result := M_Assets.AsCurrency;
end;

procedure TPerson._SetAssets(const NewValue: Currency);
begin
  M_Assets.AsCurrency := NewValue;
end;

function TPerson._Get_M_BirthDate: TBADate;
begin
  assert(ValidateMember('TPerson', 'BirthDate', 3, TBADate));
  Result := TBADate(BoldMembers[3]);
end;

function TPerson._GetBirthDate: TDate;
begin
  Result := M_BirthDate.AsDate;
end;

procedure TPerson._SetBirthDate(const NewValue: TDate);
begin
  M_BirthDate.AsDate := NewValue;
end;

function TPerson._Get_M_IsActive: TBABoolean;
begin
  assert(ValidateMember('TPerson', 'IsActive', 4, TBABoolean));
  Result := TBABoolean(BoldMembers[4]);
end;

function TPerson._GetIsActive: Boolean;
begin
  Result := M_IsActive.AsBoolean;
end;

procedure TPerson._SetIsActive(const NewValue: Boolean);
begin
  M_IsActive.AsBoolean := NewValue;
end;

function TPerson._Get_M_FullName: TBAString;
begin
  assert(ValidateMember('TPerson', 'FullName', 5, TBAString));
  Result := TBAString(BoldMembers[5]);
end;

function TPerson._GetFullName: String;
begin
  Result := M_FullName.AsString;
end;

function TPerson._GetOwnedBuildings: TBuildingList;
begin
  assert(ValidateMember('TPerson', 'OwnedBuildings', 6, TBuildingList));
  Result := TBuildingList(BoldMembers[6]);
end;

function TPerson._GetOwnership: TOwnershipList;
begin
  assert(ValidateMember('TPerson', 'Ownership', 7, TOwnershipList));
  Result := TOwnershipList(BoldMembers[7]);
end;

function TPerson._Get_M_Home: TBoldObjectReference;
begin
  assert(ValidateMember('TPerson', 'Home', 8, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[8]);
end;

function TPerson._GetHome: TResidentialBuilding;
begin
  assert(not assigned(M_Home.BoldObject) or (M_Home.BoldObject is TResidentialBuilding), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'Home', M_Home.BoldObject.ClassName, 'TResidentialBuilding']));
  Result := TResidentialBuilding(M_Home.BoldObject);
end;

procedure TPerson._SetHome(const value: TResidentialBuilding);
begin
  M_Home.BoldObject := value;
end;

function TPerson._GetManagedProjects: TProjectList;
begin
  assert(ValidateMember('TPerson', 'ManagedProjects', 9, TProjectList));
  Result := TProjectList(BoldMembers[9]);
end;

function TPerson._GetAssignedTasks: TTaskList;
begin
  assert(ValidateMember('TPerson', 'AssignedTasks', 10, TTaskList));
  Result := TTaskList(BoldMembers[10]);
end;

{ TPersonList }

procedure TPersonList.Add(NewObject: TPerson);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TPersonList.IndexOf(anObject: TPerson): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TPersonList.Includes(anObject: TPerson): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TPersonList.AddNew: TPerson;
begin
  result := TPerson(InternalAddNew);
end;

procedure TPersonList.Insert(index: Integer; NewObject: TPerson);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TPersonList.GetBoldObject(index: Integer): TPerson;
begin
  result := TPerson(GetElement(index));
end;

procedure TPersonList.SetBoldObject(index: Integer; NewObject: TPerson);
begin
  SetElement(index, NewObject);
end;

{ TBuilding }

function TBuilding._Get_M_Address: TBAString;
begin
  assert(ValidateMember('TBuilding', 'Address', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TBuilding._GetAddress: String;
begin
  Result := M_Address.AsString;
end;

procedure TBuilding._SetAddress(const NewValue: String);
begin
  M_Address.AsString := NewValue;
end;

function TBuilding._Get_M_ZipCode: TBAString;
begin
  assert(ValidateMember('TBuilding', 'ZipCode', 1, TBAString));
  Result := TBAString(BoldMembers[1]);
end;

function TBuilding._GetZipCode: String;
begin
  Result := M_ZipCode.AsString;
end;

procedure TBuilding._SetZipCode(const NewValue: String);
begin
  M_ZipCode.AsString := NewValue;
end;

function TBuilding._Get_M_City: TBAString;
begin
  assert(ValidateMember('TBuilding', 'City', 2, TBAString));
  Result := TBAString(BoldMembers[2]);
end;

function TBuilding._GetCity: String;
begin
  Result := M_City.AsString;
end;

procedure TBuilding._SetCity(const NewValue: String);
begin
  M_City.AsString := NewValue;
end;

function TBuilding._Get_M_BuiltYear: TBAInteger;
begin
  assert(ValidateMember('TBuilding', 'BuiltYear', 3, TBAInteger));
  Result := TBAInteger(BoldMembers[3]);
end;

function TBuilding._GetBuiltYear: Integer;
begin
  Result := M_BuiltYear.AsInteger;
end;

procedure TBuilding._SetBuiltYear(const NewValue: Integer);
begin
  M_BuiltYear.AsInteger := NewValue;
end;

function TBuilding._GetOwners: TPersonList;
begin
  assert(ValidateMember('TBuilding', 'Owners', 4, TPersonList));
  Result := TPersonList(BoldMembers[4]);
end;

function TBuilding._GetOwnership: TOwnershipList;
begin
  assert(ValidateMember('TBuilding', 'Ownership', 5, TOwnershipList));
  Result := TOwnershipList(BoldMembers[5]);
end;

{ TBuildingList }

procedure TBuildingList.Add(NewObject: TBuilding);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBuildingList.IndexOf(anObject: TBuilding): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBuildingList.Includes(anObject: TBuilding): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBuildingList.AddNew: TBuilding;
begin
  result := TBuilding(InternalAddNew);
end;

procedure TBuildingList.Insert(index: Integer; NewObject: TBuilding);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBuildingList.GetBoldObject(index: Integer): TBuilding;
begin
  result := TBuilding(GetElement(index));
end;

procedure TBuildingList.SetBoldObject(index: Integer; NewObject: TBuilding);
begin
  SetElement(index, NewObject);
end;

{ TResidentialBuilding }

function TResidentialBuilding._Get_M_Apartments: TBAInteger;
begin
  assert(ValidateMember('TResidentialBuilding', 'Apartments', 6, TBAInteger));
  Result := TBAInteger(BoldMembers[6]);
end;

function TResidentialBuilding._GetApartments: Integer;
begin
  Result := M_Apartments.AsInteger;
end;

procedure TResidentialBuilding._SetApartments(const NewValue: Integer);
begin
  M_Apartments.AsInteger := NewValue;
end;

function TResidentialBuilding._Get_M_MonthlyRent: TBACurrency;
begin
  assert(ValidateMember('TResidentialBuilding', 'MonthlyRent', 7, TBACurrency));
  Result := TBACurrency(BoldMembers[7]);
end;

function TResidentialBuilding._GetMonthlyRent: Currency;
begin
  Result := M_MonthlyRent.AsCurrency;
end;

procedure TResidentialBuilding._SetMonthlyRent(const NewValue: Currency);
begin
  M_MonthlyRent.AsCurrency := NewValue;
end;

function TResidentialBuilding._GetResidents: TPersonList;
begin
  assert(ValidateMember('TResidentialBuilding', 'Residents', 8, TPersonList));
  Result := TPersonList(BoldMembers[8]);
end;

{ TResidentialBuildingList }

procedure TResidentialBuildingList.Add(NewObject: TResidentialBuilding);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TResidentialBuildingList.IndexOf(anObject: TResidentialBuilding): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TResidentialBuildingList.Includes(anObject: TResidentialBuilding): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TResidentialBuildingList.AddNew: TResidentialBuilding;
begin
  result := TResidentialBuilding(InternalAddNew);
end;

procedure TResidentialBuildingList.Insert(index: Integer; NewObject: TResidentialBuilding);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TResidentialBuildingList.GetBoldObject(index: Integer): TResidentialBuilding;
begin
  result := TResidentialBuilding(GetElement(index));
end;

procedure TResidentialBuildingList.SetBoldObject(index: Integer; NewObject: TResidentialBuilding);
begin
  SetElement(index, NewObject);
end;

{ TCommercialBuilding }

function TCommercialBuilding._Get_M_OfficeSpace: TBAInteger;
begin
  assert(ValidateMember('TCommercialBuilding', 'OfficeSpace', 6, TBAInteger));
  Result := TBAInteger(BoldMembers[6]);
end;

function TCommercialBuilding._GetOfficeSpace: Integer;
begin
  Result := M_OfficeSpace.AsInteger;
end;

procedure TCommercialBuilding._SetOfficeSpace(const NewValue: Integer);
begin
  M_OfficeSpace.AsInteger := NewValue;
end;

function TCommercialBuilding._Get_M_ParkingSpaces: TBAInteger;
begin
  assert(ValidateMember('TCommercialBuilding', 'ParkingSpaces', 7, TBAInteger));
  Result := TBAInteger(BoldMembers[7]);
end;

function TCommercialBuilding._GetParkingSpaces: Integer;
begin
  Result := M_ParkingSpaces.AsInteger;
end;

procedure TCommercialBuilding._SetParkingSpaces(const NewValue: Integer);
begin
  M_ParkingSpaces.AsInteger := NewValue;
end;

{ TCommercialBuildingList }

procedure TCommercialBuildingList.Add(NewObject: TCommercialBuilding);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TCommercialBuildingList.IndexOf(anObject: TCommercialBuilding): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TCommercialBuildingList.Includes(anObject: TCommercialBuilding): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TCommercialBuildingList.AddNew: TCommercialBuilding;
begin
  result := TCommercialBuilding(InternalAddNew);
end;

procedure TCommercialBuildingList.Insert(index: Integer; NewObject: TCommercialBuilding);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TCommercialBuildingList.GetBoldObject(index: Integer): TCommercialBuilding;
begin
  result := TCommercialBuilding(GetElement(index));
end;

procedure TCommercialBuildingList.SetBoldObject(index: Integer; NewObject: TCommercialBuilding);
begin
  SetElement(index, NewObject);
end;

{ TOwnership }

function TOwnership._Get_M_Share: TBAFloat;
begin
  assert(ValidateMember('TOwnership', 'Share', 0, TBAFloat));
  Result := TBAFloat(BoldMembers[0]);
end;

function TOwnership._GetShare: Double;
begin
  Result := M_Share.AsFloat;
end;

procedure TOwnership._SetShare(const NewValue: Double);
begin
  M_Share.AsFloat := NewValue;
end;

function TOwnership._Get_M_AcquiredDate: TBADate;
begin
  assert(ValidateMember('TOwnership', 'AcquiredDate', 1, TBADate));
  Result := TBADate(BoldMembers[1]);
end;

function TOwnership._GetAcquiredDate: TDate;
begin
  Result := M_AcquiredDate.AsDate;
end;

procedure TOwnership._SetAcquiredDate(const NewValue: TDate);
begin
  M_AcquiredDate.AsDate := NewValue;
end;

function TOwnership._Get_M_OwnedBuildings: TBoldObjectReference;
begin
  assert(ValidateMember('TOwnership', 'OwnedBuildings', 2, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[2]);
end;

function TOwnership._GetOwnedBuildings: TBuilding;
begin
  assert(not assigned(M_OwnedBuildings.BoldObject) or (M_OwnedBuildings.BoldObject is TBuilding), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'OwnedBuildings', M_OwnedBuildings.BoldObject.ClassName, 'TBuilding']));
  Result := TBuilding(M_OwnedBuildings.BoldObject);
end;

function TOwnership._Get_M_Owners: TBoldObjectReference;
begin
  assert(ValidateMember('TOwnership', 'Owners', 3, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[3]);
end;

function TOwnership._GetOwners: TPerson;
begin
  assert(not assigned(M_Owners.BoldObject) or (M_Owners.BoldObject is TPerson), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'Owners', M_Owners.BoldObject.ClassName, 'TPerson']));
  Result := TPerson(M_Owners.BoldObject);
end;

{ TOwnershipList }

procedure TOwnershipList.Add(NewObject: TOwnership);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TOwnershipList.IndexOf(anObject: TOwnership): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TOwnershipList.Includes(anObject: TOwnership): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TOwnershipList.AddNew: TOwnership;
begin
  result := TOwnership(InternalAddNew);
end;

procedure TOwnershipList.Insert(index: Integer; NewObject: TOwnership);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TOwnershipList.GetBoldObject(index: Integer): TOwnership;
begin
  result := TOwnership(GetElement(index));
end;

procedure TOwnershipList.SetBoldObject(index: Integer; NewObject: TOwnership);
begin
  SetElement(index, NewObject);
end;

{ TProject }

function TProject._Get_M_Name: TBAString;
begin
  assert(ValidateMember('TProject', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TProject._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure TProject._SetName(const NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

function TProject._Get_M_Description: TBAString;
begin
  assert(ValidateMember('TProject', 'Description', 1, TBAString));
  Result := TBAString(BoldMembers[1]);
end;

function TProject._GetDescription: String;
begin
  Result := M_Description.AsString;
end;

procedure TProject._SetDescription(const NewValue: String);
begin
  M_Description.AsString := NewValue;
end;

function TProject._Get_M_StartDate: TBADate;
begin
  assert(ValidateMember('TProject', 'StartDate', 2, TBADate));
  Result := TBADate(BoldMembers[2]);
end;

function TProject._GetStartDate: TDate;
begin
  Result := M_StartDate.AsDate;
end;

procedure TProject._SetStartDate(const NewValue: TDate);
begin
  M_StartDate.AsDate := NewValue;
end;

function TProject._Get_M_EndDate: TBADate;
begin
  assert(ValidateMember('TProject', 'EndDate', 3, TBADate));
  Result := TBADate(BoldMembers[3]);
end;

function TProject._GetEndDate: TDate;
begin
  Result := M_EndDate.AsDate;
end;

procedure TProject._SetEndDate(const NewValue: TDate);
begin
  M_EndDate.AsDate := NewValue;
end;

function TProject._Get_M_Budget: TBACurrency;
begin
  assert(ValidateMember('TProject', 'Budget', 4, TBACurrency));
  Result := TBACurrency(BoldMembers[4]);
end;

function TProject._GetBudget: Currency;
begin
  Result := M_Budget.AsCurrency;
end;

procedure TProject._SetBudget(const NewValue: Currency);
begin
  M_Budget.AsCurrency := NewValue;
end;

function TProject._Get_M_Manager: TBoldObjectReference;
begin
  assert(ValidateMember('TProject', 'Manager', 5, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[5]);
end;

function TProject._GetManager: TPerson;
begin
  assert(not assigned(M_Manager.BoldObject) or (M_Manager.BoldObject is TPerson), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'Manager', M_Manager.BoldObject.ClassName, 'TPerson']));
  Result := TPerson(M_Manager.BoldObject);
end;

procedure TProject._SetManager(const value: TPerson);
begin
  M_Manager.BoldObject := value;
end;

function TProject._GetTasks: TTaskList;
begin
  assert(ValidateMember('TProject', 'Tasks', 6, TTaskList));
  Result := TTaskList(BoldMembers[6]);
end;

procedure TProject.CompleteCreate;
begin
  inherited;
  Inc(FProjectCounter);
  Name := 'Project' + IntToStr(FProjectCounter);
end;

class procedure TProject.InitializeCounter(ASystem: TBoldSystem);
var
  Projects: TBoldObjectList;
  i, Num, MaxNum: Integer;
  ProjName: string;
begin
  MaxNum := 0;
  Projects := ASystem.Classes[ASystem.BoldSystemTypeInfo.ClassTypeInfoByExpressionName['Project'].TopSortedIndex];
  for i := 0 to Projects.Count - 1 do
  begin
    ProjName := TProject(Projects[i]).Name;
    if ProjName.StartsWith('Project') then
    begin
      if TryStrToInt(Copy(ProjName, 8, MaxInt), Num) then
        if Num > MaxNum then
          MaxNum := Num;
    end;
  end;
  FProjectCounter := MaxNum;
end;

{ TProjectList }

procedure TProjectList.Add(NewObject: TProject);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TProjectList.IndexOf(anObject: TProject): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TProjectList.Includes(anObject: TProject): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TProjectList.AddNew: TProject;
begin
  result := TProject(InternalAddNew);
end;

procedure TProjectList.Insert(index: Integer; NewObject: TProject);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TProjectList.GetBoldObject(index: Integer): TProject;
begin
  result := TProject(GetElement(index));
end;

procedure TProjectList.SetBoldObject(index: Integer; NewObject: TProject);
begin
  SetElement(index, NewObject);
end;

{ TTask }

function TTask._Get_M_Title: TBAString;
begin
  assert(ValidateMember('TTask', 'Title', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TTask._GetTitle: String;
begin
  Result := M_Title.AsString;
end;

procedure TTask._SetTitle(const NewValue: String);
begin
  M_Title.AsString := NewValue;
end;

function TTask._Get_M_Priority: TBAInteger;
begin
  assert(ValidateMember('TTask', 'Priority', 1, TBAInteger));
  Result := TBAInteger(BoldMembers[1]);
end;

function TTask._GetPriority: Integer;
begin
  Result := M_Priority.AsInteger;
end;

procedure TTask._SetPriority(const NewValue: Integer);
begin
  M_Priority.AsInteger := NewValue;
end;

function TTask._Get_M_IsCompleted: TBABoolean;
begin
  assert(ValidateMember('TTask', 'IsCompleted', 2, TBABoolean));
  Result := TBABoolean(BoldMembers[2]);
end;

function TTask._GetIsCompleted: Boolean;
begin
  Result := M_IsCompleted.AsBoolean;
end;

procedure TTask._SetIsCompleted(const NewValue: Boolean);
begin
  M_IsCompleted.AsBoolean := NewValue;
end;

function TTask._Get_M_DueDate: TBADate;
begin
  assert(ValidateMember('TTask', 'DueDate', 3, TBADate));
  Result := TBADate(BoldMembers[3]);
end;

function TTask._GetDueDate: TDate;
begin
  Result := M_DueDate.AsDate;
end;

procedure TTask._SetDueDate(const NewValue: TDate);
begin
  M_DueDate.AsDate := NewValue;
end;

function TTask._Get_M_Project: TBoldObjectReference;
begin
  assert(ValidateMember('TTask', 'Project', 4, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[4]);
end;

function TTask._GetProject: TProject;
begin
  assert(not assigned(M_Project.BoldObject) or (M_Project.BoldObject is TProject), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'Project', M_Project.BoldObject.ClassName, 'TProject']));
  Result := TProject(M_Project.BoldObject);
end;

procedure TTask._SetProject(const value: TProject);
begin
  M_Project.BoldObject := value;
end;

function TTask._Get_M_AssignedTo: TBoldObjectReference;
begin
  assert(ValidateMember('TTask', 'AssignedTo', 5, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[5]);
end;

function TTask._GetAssignedTo: TPerson;
begin
  assert(not assigned(M_AssignedTo.BoldObject) or (M_AssignedTo.BoldObject is TPerson), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'AssignedTo', M_AssignedTo.BoldObject.ClassName, 'TPerson']));
  Result := TPerson(M_AssignedTo.BoldObject);
end;

procedure TTask._SetAssignedTo(const value: TPerson);
begin
  M_AssignedTo.BoldObject := value;
end;

procedure TTask.CompleteCreate;
begin
  inherited;
  Inc(FTaskCounter);
  Title := 'Task' + IntToStr(FTaskCounter);
end;

class procedure TTask.InitializeCounter(ASystem: TBoldSystem);
var
  Tasks: TBoldObjectList;
  i, Num, MaxNum: Integer;
  TaskTitle: string;
begin
  MaxNum := 0;
  Tasks := ASystem.Classes[ASystem.BoldSystemTypeInfo.ClassTypeInfoByExpressionName['Task'].TopSortedIndex];
  for i := 0 to Tasks.Count - 1 do
  begin
    TaskTitle := TTask(Tasks[i]).Title;
    if TaskTitle.StartsWith('Task') then
    begin
      if TryStrToInt(Copy(TaskTitle, 5, MaxInt), Num) then
        if Num > MaxNum then
          MaxNum := Num;
    end;
  end;
  FTaskCounter := MaxNum;
end;

{ TTaskList }

procedure TTaskList.Add(NewObject: TTask);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TTaskList.IndexOf(anObject: TTask): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TTaskList.Includes(anObject: TTask): Boolean;
begin
  result := IncludesElement(anObject);
end;

function TTaskList.AddNew: TTask;
begin
  result := TTask(InternalAddNew);
end;

procedure TTaskList.Insert(index: Integer; NewObject: TTask);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TTaskList.GetBoldObject(index: Integer): TTask;
begin
  result := TTask(GetElement(index));
end;

procedure TTaskList.SetBoldObject(index: Integer; NewObject: TTask);
begin
  SetElement(index, NewObject);
end;

{ Registration }

function GeneratedCodeCRC: String;
begin
  result := '635243925';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('Person', TPersonList);
  BoldObjectListClasses.AddObjectEntry('Building', TBuildingList);
  BoldObjectListClasses.AddObjectEntry('ResidentialBuilding', TResidentialBuildingList);
  BoldObjectListClasses.AddObjectEntry('CommercialBuilding', TCommercialBuildingList);
  BoldObjectListClasses.AddObjectEntry('Ownership', TOwnershipList);
  BoldObjectListClasses.AddObjectEntry('Project', TProjectList);
  BoldObjectListClasses.AddObjectEntry('Task', TTaskList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('Person', TPerson);
  BoldObjectClasses.AddObjectEntry('Building', TBuilding);
  BoldObjectClasses.AddObjectEntry('ResidentialBuilding', TResidentialBuilding);
  BoldObjectClasses.AddObjectEntry('CommercialBuilding', TCommercialBuilding);
  BoldObjectClasses.AddObjectEntry('Ownership', TOwnership);
  BoldObjectClasses.AddObjectEntry('Project', TProject);
  BoldObjectClasses.AddObjectEntry('Task', TTask);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('DemoModel', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.
